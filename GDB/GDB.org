* GDB 调试程序
** 基本命令
   l（list）：查看源代码
   list 函数名：查看函数的源代码
   l n1, n2 ：查看特定范围的源代码
   l main ： 显示特定函数源代码
   set listsize 50 ： 修改源代码显示行数
   backtrace/bt: 查看各级函数调用以及参数
   在gdb中运行，遇到段错误会自动停下来，这时可以用bt命令查看当前执行到哪一行代码了
   如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误
*** 断点
    b main：在函数main出设置断点
    b 13 ： 在源代码13行处设置断点
    b(break)：将下一行设置断点
    tbreak：设置临时断点（中断后失效）
    info breakpoints：查看所有断点信息
    d 3：delete，删除断点3，也可以使用范围“d 1-3”，无参数时删除全部断点
    disable 2 ： 禁用断点，也可以使用范围“disable 1-3”
    enable 2 ：启用断点2，也可以使用范围“enable 1-3”
    delete breakpoint x: 删除某个断点
    delete breakpoints：删除所有的断点
    ignore 2 1：忽略2号中断一次
    条件式中断：
    b test if a == 10
    condition 4 a == 30
    break 行号 if ... :如果满足某个条件可以再第9行设置一个断点
*** 执行
    start：开始执行程序，停止在main函数第一行语句前等待
    r：执行
    n：单步执行，不跟踪到函数内部，step over
    s：单步执行，跟踪到函数内部，step in
    finish：继续执行直到当前函数结束，step out
    c： continue，执行执行，直到下一个断点
*** 堆栈
    where：查看调用堆栈，相同作用的命令还有info s, bt
    frame/f：查看当前堆栈，还可以显示当前代码
    info frame：获取当前堆栈更详细的信息
    可以用frame修改当前堆栈帧，然后查看其详细信息
    frame 1,切换到桢为1的，i locals:查看当前帧的局部变量
*** 变量和参数
    info locals：显示局部变量
    info args：显示函数参数（自变量）
    p a：print 显示变量a的值
    p/x a：以16进制显示变量a的值
    p a + b：计算a + b的值
    x命令内存输出格式：
    d：十进制，u：十进制无符号，x：16进制，o：8进制，t：2进制，c：字符
    set variable：可用来修改变量的值， set variable a=100
    p variable=xx: 设置变量的值
    display variable: 一直显示某个变量的值
    undisplay variable: 取消一直显示某个变量的值
*** 内存及寄存器/x命令
    x命令可以显示指定地址的内存数据
    格式：x/nfu [address]，
    n：显示内存单位（组或者行），f：格式，除了print格式外，还有字符串s和汇编i
    u：内存单位，b：1字节，h：2字节， w：4字节，g：8字节
    x/8w 0x0804843b //按4字节显示8组内存数据
    x/8i 0x0804843b // 显示8行汇编指令
    x/x //以16进制输出
    x/d //以10进制输出
    x/c //以单子符输出
    x/s //以字符串输出
    info registers // 显示所有寄存器数据
    p $eax // 显示单个寄存器的值
    在打印一个序列化过的结构体， 如果序列太长，往往会被gdb省略掉，此时可以设置
    set print elements 0即可
    watch：设置观察点，例如：watch variable
*** 反汇编代码
    set disassembly-flavor intel // 设置反汇编指令的格式
    disass funname // 反汇编funname函数
    可以用b *address设置汇编断点，然后用si和ni进行汇编级单步执行，这对于分析指针和
    寻址非常有用
*** 进程
    help info proc stat
    info proc mappings // 等价于 cat /proc/{pid}/maps
*** 线程
    可以在pthread_create处设置断点，当线程创建时会生成提示信息
    info thread // 查看所有线程列表
    thread 1 // 切换线程
*** 其他
    set follow-fork-mode child
    shell // 临时进入shell执行命令，exit返回
    call test("abc") // 调试时直接调用函数
    gdb --tui hello // 在终端窗口上显示一个源代码查看窗口
*** core dump
    ulimit -a // 查看系统的设置信息
    core file size (blocks, -c) 0：意味着在程序崩溃时不会生成core dump文件
    修改一下：sudo sh -c "ulimit -c unlimited; ./test" //执行test时，产所core文件

    gdb test core，此时最后几行提示会告诉我们错误的原因和代码位置，接下来就是gdb的
    技巧了，可以先输入where查看调用堆栈，info files 查看信息
    
** GDB中应该知道的几个调试方法
   http://coolshell.cn/articles/3643.html
*** 多线程调试
    最重要的几个命令如下：
    info thread: 查看当前进程的线程
    thread <ID>: 切换调试的线程为指定ID的线程
    break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点
    set scheduler-locking off|on|step:
    off 不锁定任何线程，也就是所有线程都执行，这是默认值
    on 只有当前被调试程序会执行
    step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行
*** 调试宏
    在GCC 编译程序时，加上-ggdb3参数，就可以调试宏了
    info macro 可以查看这个宏在哪些文件里被引用了，以及宏定义
    macro - 可以查看宏展开的样子
*** 条件断点
    语法： break [where] if [condition]
*** 命令行参数
    gdb命令行中的 -args 参数
    gdb环境中set args命令
    gdb环境中，run 后加参数，如：run 1 2或则 (r 1 2)
*** gdb的变量
    gdb中的变量就像shell一样，gdb中的变量以$开头，例如：
    set $i = 0
    p a[$i++]
*** command命令
    将一组gdb命令打包，例如：
    break func
    command 1
    print arg1
    print arg2
    print arg3
    end
    
